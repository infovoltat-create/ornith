
* /* 
 * HELIOS Master Firmware - v19.0 (Hybrid Navigation)
 * 
 * CHANGE LOG v19.0:
 * - RESTORED: All original v16/v17 screens (Home, Network Local, Network Cloud, Info, Reset)
 * - ADDED: New Settings system as a sub-menu accessible from Network Cloud screen
 * - UNIFIED: Hierarchical navigation system (Home → Network → Settings)
 * - IMPROVED: Factory reset with confirmation screen
 * - MAINTAINED: All enhanced features (Buzzer, Slave, Hysteresis controls)
 * - OPTIMIZED: Clean screen transitions with back navigation
 * 
 * CORE FEATURES:
 * - Master-Slave UDP Coordination
 * - Complete Navigation System
 * - Advanced Settings Configuration
 * - Full App Compatibility (MQTT + Local API)
 * - Original v16/v17 UI + New Settings
 */

#include <Arduino.h>
#include <Wire.h>
#include <U8g2lib.h>
#include <Adafruit_AHTX0.h>
#include <ESP8266WiFi.h>
#include <ESP8266WebServer.h>
#include <WiFiUdp.h>
#include <EEPROM.h>
#include <PubSubClient.h>
#include <ArduinoJson.h>
#include <ESP8266mDNS.h>
#include <ArduinoOTA.h>
#include <ESP8266HTTPUpdateServer.h>

// ==================== DEBUG CONFIGURATION ====================
// #define SERIAL_DEBUG
#ifdef SERIAL_DEBUG
  #define DEBUG_PRINT(x) Serial.print(x)
  #define DEBUG_PRINTLN(x) Serial.println(x)
  #define DEBUG_PRINTF(...) Serial.printf(__VA_ARGS__)
#else
  #define DEBUG_PRINT(x)
  #define DEBUG_PRINTLN(x)
  #define DEBUG_PRINTF(...)
#endif

// ==================== HARDWARE CONFIGURATION ====================
#define RELAY_PIN   D0 
#define BTN_UP      D5 
#define BTN_DOWN    D6 
#define BTN_SELECT  D7 
#define BUZZER_PIN  D8 
#define SDA_PIN     D2 
#define SCL_PIN     D1 

// --- System Timings ---
#define DISPLAY_UPDATE_MS     33
#define SENSOR_READ_MS        2000
#define HEARTBEAT_MS          1000
#define SLAVE_TIMEOUT_MS      45000
#define MQTT_RECONNECT_MS     5000
#define RESET_HOLD_MS         5000
#define RESET_DEBOUNCE_MS     300
#define LONG_PRESS_MS         1000
#define WATCHDOG_TIMEOUT      30000
#define SCROLL_ANIMATION_MS   150
#define INTERNET_CHECK_MS     10000
#define BUTTON_DEBOUNCE_MS    50

// ==================== SETTINGS STRUCTURES ====================
struct SystemSettings {
  bool buzzerEnabled = true;
  bool slaveControlEnabled = true;
  bool mqttNotifications = true;
  float hysteresisLow = 0.3;
  float hysteresisHigh = 0.1;
  uint8_t displayBrightness = 255;
  uint8_t magic = 0xAA;
};
SystemSettings systemSettings;

// --- MQTT Configuration ---
const char* mqtt_server = "2029c2a3fad64b4185467bdeb78ad7c1.s1.eu.hivemq.cloud";
const int mqtt_port = 8883;
const char* mqtt_user = "Helios";
const char* mqtt_pass = "88v3dzsE";
const char* topic_status = "followers/status";
const char* topic_cmd    = "helios/cmd";
const char* topic_notifications = "helios/notifications";

// ==================== OBJECTS ====================
U8G2_SSD1306_128X64_NONAME_F_HW_I2C display(U8G2_R0, U8X8_PIN_NONE, SCL_PIN, SDA_PIN);
Adafruit_AHTX0 aht;
ESP8266WebServer server(80);
WiFiUDP udp;
WiFiClientSecure espClient;
PubSubClient mqttClient(espClient);
ESP8266HTTPUpdateServer httpUpdater;

// ==================== STATE STRUCTURES ====================
struct WifiSettings { 
  char ssid[32]; 
  char pass[32]; 
  uint8_t magic;
};
WifiSettings wifiCreds;

enum SystemMode { MODE_HEAT = 0, MODE_TIMER = 1, MODE_CYCLE = 2 };
enum SystemError { ERR_NONE = 0, ERR_SLAVE_LOST = 1, ERR_SENSOR_FAIL = 2, ERR_WIFI_LOST = 3 };
enum ScreenId { 
  SCREEN_HOME,                // Main temperature display
  SCREEN_NET_LOCAL,           // Local network status (AP, Slave)
  SCREEN_NET_CLOUD,           // Cloud connectivity (WiFi, MQTT, Internet)
  SCREEN_SETTINGS_MAIN,       // Main settings menu
  SCREEN_SETTINGS_BUZZER,     // Buzzer settings
  SCREEN_SETTINGS_SLAVE,      // Slave control settings
  SCREEN_SETTINGS_HYSTERESIS, // Hysteresis settings
  SCREEN_SETTINGS_NOTIFICATIONS, // Notification settings
  SCREEN_SETTINGS_DISPLAY,    // Display settings
  SCREEN_INFO,                // Company info (v16/v17 style)
  SCREEN_RESET,               // Factory reset
  SCREEN_RESET_CONFIRM,       // Reset confirmation
  SCREEN_COUNT 
};
enum ConfirmationOption { OPTION_YES = 0, OPTION_NO = 1 };
enum NavDirection { NAV_LEFT = -1, NAV_RIGHT = 1 };

// ==================== GLOBAL STATE ====================
float temperature = 0.0;
float humidity = 0.0;
bool relayActive = false;
bool systemEnabled = false;
SystemMode currentMode = MODE_HEAT;
float targetTemperature = 22.0;

unsigned long timerEndTime = 0;
unsigned long cycleOnEnd = 0;
unsigned long cycleOffEnd = 0;
bool cycleActive = false;

// Confirmation UI
float pendingTargetTemp = 0.0;
bool pendingRelayState = false;
bool showConfirmPopup = false;
ConfirmationOption selectedOption = OPTION_YES;
int optionScrollOffset = 0;
unsigned long lastScrollTime = 0;

// Network State
bool apModeActive = false; 
bool startupApLaunched = false;
bool internetAvailable = false;
const char* apSSID = "HELIOS_MASTER";
const char* apPass = "12345678";
const int udpPort = 4210;
char packetBuffer[64];

// Safety System
unsigned long lastSlavePacketTime = 0;
bool slaveKnown = false; 
SystemError currentError = ERR_NONE;
bool errorDismissed = false;
unsigned long watchdogTimer = 0;

// UI & Navigation
ScreenId currentScreen = SCREEN_HOME;
ScreenId targetScreen = SCREEN_HOME;
ScreenId previousScreen = SCREEN_HOME;
int screenOffset = 0; 
bool isAnimating = false;
unsigned long selectPressStart = 0, upPressStart = 0, downPressStart = 0;
bool longPressTriggered = false;
unsigned long resetHoldStart = 0; 
bool buttonHandled = false;
int settingsCursor = 0;
bool inSettingsSubMenu = false;

// Timers
unsigned long now = 0;
unsigned long t_display = 0, t_sensor = 0, t_heartbeat = 0, t_internet = 0;
unsigned long t_input = 0, t_mqtt_retry = 0;
unsigned long targetDisplayTimeout = 0, lastRelayToggle = 0, lastTempAdjustTime = 0;
unsigned long lastStatusPublish = 0;
unsigned long systemStartTime = 0;

// ==================== WEB UI ====================
const char INDEX_HTML[] PROGMEM = R"rawliteral(
<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><title>Helios Systems</title>
<style>:root{--bg:#121212;--c:#1e1e1e;--t:#e0e0e0;--a:#00e676}body{background:var(--bg);color:var(--t);font-family:sans-serif;padding:20px;text-align:center}
.card{background:var(--c);border-radius:12px;padding:20px;margin-bottom:15px}h1{color:var(--a);margin:0}textarea{width:100%;background:#000;color:var(--a);border:1px solid #333;padding:10px}
.setting{display:flex;justify-content:space-between;margin:10px 0;padding:10px;background:#252525;border-radius:8px}
.toggle{width:50px;height:24px;background:#555;border-radius:12px;position:relative;cursor:pointer}
.toggle.active{background:#00e676}.toggle-knob{width:20px;height:20px;background:#fff;border-radius:50%;position:absolute;top:2px;transition:left 0.2s}
</style></head><body>
<div class="card"><h1>Helios Systems</h1><p>Master Hub v19.0</p></div>
<div class="card"><h3>Slave Credentials</h3><textarea readonly onclick="this.select()">{"role":"SLAVE","ssid":"HELIOS_MASTER","pass":"12345678","relay_pin":2,"led_pin":1,"sensors":false}</textarea></div>
<div class="card"><h3>Firmware Update</h3><a href="/update"><button>Upload Firmware</button></a></div>
</body></html>
)rawliteral";

// ==================== UTILITY FUNCTIONS ====================
void playTone(int freq, int duration) {
  if (!systemSettings.buzzerEnabled) return;
  tone(BUZZER_PIN, freq, duration);
}

void playStartupSound() {
  if (!systemSettings.buzzerEnabled) return;
  int melody[] = { 262, 330, 392, 523 }; 
  for (int i = 0; i < 4; i++) {
    tone(BUZZER_PIN, melody[i], 100); 
    delay(120); 
    noTone(BUZZER_PIN);
  }
}

void toggleAPMode(bool enable) {
  apModeActive = enable;
  if (enable) {
    WiFi.mode(WIFI_AP_STA);
    WiFi.softAP(apSSID, apPass);
    udp.begin(udpPort);
    server.begin();
  } else {
    server.stop();
    udp.stop();
    WiFi.enableAP(false);
  }
}

void saveSystemSettings() {
  systemSettings.magic = 0xAA;
  EEPROM.put(100, systemSettings);
  EEPROM.commit();
}

void loadSystemSettings() {
  EEPROM.get(100, systemSettings);
  if (systemSettings.magic != 0xAA) {
    systemSettings.buzzerEnabled = true;
    systemSettings.slaveControlEnabled = true;
    systemSettings.mqttNotifications = true;
    systemSettings.hysteresisLow = 0.3;
    systemSettings.hysteresisHigh = 0.1;
    systemSettings.displayBrightness = 255;
    systemSettings.magic = 0xAA;
    saveSystemSettings();
  }
}

// ==================== NAVIGATION FUNCTIONS ====================
void navigateTo(ScreenId target, NavDirection direction = NAV_RIGHT) {
  if (currentScreen == target || isAnimating) return;
  
  targetScreen = target;
  screenOffset = (direction == NAV_RIGHT) ? 128 : -128;
  isAnimating = true;
  
  // Play navigation sound
  playTone(800, 30);
}

void navigateBack() {
  if (inSettingsSubMenu) {
    // Go back from settings sub-menu to main settings
    inSettingsSubMenu = false;
    navigateTo(SCREEN_SETTINGS_MAIN, NAV_LEFT);
  } else if (currentScreen == SCREEN_SETTINGS_MAIN) {
    // Go from settings to network cloud
    navigateTo(SCREEN_NET_CLOUD, NAV_LEFT);
  } else {
    // Go to home screen
    navigateTo(SCREEN_HOME, NAV_LEFT);
  }
}

// ==================== INTERNET PROBING ====================
bool probeInternet() {
  IPAddress ip;
  const char* host = "clients3.google.com";
  const int port = 80;
  if (!WiFi.hostByName(host, ip)) return false;
  
  WiFiClient client;
  if (!client.connect(ip, port)) return false;
  
  client.print(String("GET /generate_204 HTTP/1.1\r\nHost: ") + host + "\r\nConnection: close\r\n\r\n");
  unsigned long start = millis();
  while (!client.available()) {
    if (millis() - start > 1200) { client.stop(); return false; }
  }
  String line = client.readStringUntil('\r');
  client.stop();
  return (line.indexOf("204") >= 0 || line.indexOf("200") >= 0);
}

// ==================== MQTT & COMMUNICATION ====================
void sendNotification(const char* title, const char* message) {
  if (!systemSettings.mqttNotifications || !mqttClient.connected()) return;
  
  StaticJsonDocument<128> doc;
  doc["title"] = title;
  doc["message"] = message;
  doc["timestamp"] = now;
  
  char notif[256];
  serializeJson(doc, notif);
  mqttClient.publish(topic_notifications, notif);
}

void publishStatus(const char* trigger) {
  if (!mqttClient.connected()) return;
  
  StaticJsonDocument<256> doc;
  doc["relay"] = relayActive;
  doc["temp"] = temperature;
  doc["target"] = targetTemperature;
  doc["humidity"] = humidity;
  doc["trigger"] = trigger;
  doc["mode"] = (int)currentMode;
  doc["enabled"] = systemEnabled;
  
  char msg[256];
  serializeJson(doc, msg);
  mqttClient.publish(topic_status, msg);
}

void processCommand(const char* jsonPayload, const char* source) {
  StaticJsonDocument<256> doc;
  DeserializationError err = deserializeJson(doc, jsonPayload);
  
  if (err) {
    DEBUG_PRINTLN("JSON Parse Error");
    return;
  }

  if (doc.containsKey("type")) {
    const char* type = doc["type"];
    
    if (strcmp(type, "set_power") == 0) {
      systemEnabled = doc["value"] | false;
      if (!systemEnabled) setRelayState(false, "CMD_POWER");
      publishStatus("CMD_POWER");
      sendNotification("Power", systemEnabled ? "System ON" : "System OFF");
    }
    else if (strcmp(type, "set_target") == 0) {
      targetTemperature = doc["value"] | 22.0;
      targetDisplayTimeout = now + 1500;
      publishStatus("CMD_TARGET");
    }
    else if (strcmp(type, "set_mode") == 0) {
      const char* modeVal = doc["value"];
      if (strcmp(modeVal, "timer") == 0) {
        currentMode = MODE_TIMER;
        sendNotification("Mode", "Timer mode activated");
      } else if (strcmp(modeVal, "cycle") == 0) {
        currentMode = MODE_CYCLE;
        sendNotification("Mode", "Cycle mode activated");
      } else {
        currentMode = MODE_HEAT;
        sendNotification("Mode", "Heat mode activated");
      }
      publishStatus("CMD_MODE");
    }
    else if (strcmp(type, "set_timer") == 0) {
      unsigned long seconds = doc["seconds"] | 0;
      timerEndTime = now + (seconds * 1000);
      currentMode = MODE_TIMER;
      systemEnabled = true;
      char timerMsg[50];
      snprintf(timerMsg, sizeof(timerMsg), "%lu min timer started", seconds / 60);
      sendNotification("Timer Set", timerMsg);
      publishStatus("CMD_TIMER");
    }
    else if (strcmp(type, "set_cycle") == 0) {
      unsigned long onSec = doc["on_sec"] | 0;
      unsigned long offSec = doc["off_sec"] | 0;
      cycleOnEnd = now + (onSec * 1000);
      cycleOffEnd = 0;
      cycleActive = true;
      currentMode = MODE_CYCLE;
      systemEnabled = true;
      char cycleMsg[80];
      snprintf(cycleMsg, sizeof(cycleMsg), "%lu min ON, %lu min OFF", onSec / 60, offSec / 60);
      sendNotification("Cycle Set", cycleMsg);
      publishStatus("CMD_CYCLE");
    }
    else if (strcmp(type, "set_wifi") == 0) {
      const char* ssid = doc["ssid"];
      const char* pass = doc["pass"];
      if (ssid && pass) {
        strlcpy(wifiCreds.ssid, ssid, sizeof(wifiCreds.ssid));
        strlcpy(wifiCreds.pass, pass, sizeof(wifiCreds.pass));
        wifiCreds.magic = 0x55;
        EEPROM.put(0, wifiCreds);
        EEPROM.commit();
        sendNotification("WiFi Updated", "Rebooting...");
        delay(1000);
        ESP.restart();
      }
    }
    else if (strcmp(type, "set_buzzer") == 0) {
      systemSettings.buzzerEnabled = doc["value"] | false;
      saveSystemSettings();
      sendNotification("Buzzer", systemSettings.buzzerEnabled ? "Enabled" : "Disabled");
    }
    else if (strcmp(type, "set_slave") == 0) {
      systemSettings.slaveControlEnabled = doc["value"] | false;
      saveSystemSettings();
      sendNotification("Slave Control", systemSettings.slaveControlEnabled ? "Enabled" : "Disabled");
    }
    else if (strcmp(type, "set_notify") == 0) {
      systemSettings.mqttNotifications = doc["value"] | false;
      saveSystemSettings();
      sendNotification("Notifications", systemSettings.mqttNotifications ? "Enabled" : "Disabled");
    }
  }
}

void mqttCallback(char* topic, byte* payload, unsigned int length) {
  payload[length] = '\0';
  processCommand((char*)payload, "MQTT");
}

void connectMqtt() {
  if (WiFi.status() != WL_CONNECTED) return;
  
  if (now - t_mqtt_retry > MQTT_RECONNECT_MS) {
    t_mqtt_retry = now;
    String clientId = "Helios-" + String(random(0xffff), HEX);
    
    if (mqttClient.connect(clientId.c_str(), mqtt_user, mqtt_pass)) {
      mqttClient.subscribe(topic_cmd);
      publishStatus("RECONNECT");
      sendNotification("System", "MQTT Connected");
    }
  }
}

// ==================== WEB HANDLERS ====================
void handleScan() {
  int n = WiFi.scanNetworks();
  String json = "[";
  for (int i = 0; i < n; ++i) {
    if (i) json += ",";
    json += "\"" + WiFi.SSID(i) + "\"";
  }
  json += "]";
  server.send(200, "application/json", json);
}

void handleSaveWifi() {
  if (server.hasArg("plain")) {
    StaticJsonDocument<128> doc;
    DeserializationError err = deserializeJson(doc, server.arg("plain"));
    if (!err && doc.containsKey("ssid") && doc.containsKey("pass")) {
      strlcpy(wifiCreds.ssid, doc["ssid"], sizeof(wifiCreds.ssid));
      strlcpy(wifiCreds.pass, doc["pass"], sizeof(wifiCreds.pass));
      wifiCreds.magic = 0x55;
      EEPROM.put(0, wifiCreds);
      EEPROM.commit();
      server.send(200, "application/json", "{\"status\":\"saved\"}");
      delay(500);
      ESP.restart();
      return;
    }
  }
  server.send(400, "application/json", "{\"status\":\"error\"}");
}

void handleCorsHeaders() {
  server.sendHeader("Access-Control-Allow-Origin", "*");
  server.sendHeader("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
  server.sendHeader("Access-Control-Allow-Headers", "Content-Type");
}

void handleApiCommand() {
  handleCorsHeaders();
  if (server.hasArg("plain")) {
    processCommand(server.arg("plain").c_str(), "API");
    server.send(200, "application/json", "{\"status\":\"ok\"}");
  } else {
    server.send(400, "application/json", "{\"status\":\"no_data\"}");
  }
}

void handleApiStatus() {
  handleCorsHeaders();
  StaticJsonDocument<256> doc;
  doc["relay"] = relayActive;
  doc["temp"] = temperature;
  doc["target"] = targetTemperature;
  doc["humidity"] = humidity;
  doc["mode"] = (int)currentMode;
  doc["enabled"] = systemEnabled;
  
  String jsonStr;
  serializeJson(doc, jsonStr);
  server.send(200, "application/json", jsonStr);
}

// ==================== HARDWARE & LOGIC ====================
void sendUdpBroadcast() {
  if (!systemSettings.slaveControlEnabled) return;
  
  StaticJsonDocument<64> doc;
  doc["id"] = "MST";
  doc["relay"] = (currentError == ERR_NONE) ? relayActive : false;
  
  char msg[64];
  serializeJson(doc, msg);
  
  IPAddress broadcastIp = WiFi.softAPIP();
  broadcastIp[3] = 255; 
  
  udp.beginPacket(broadcastIp, udpPort);
  udp.write(msg);
  udp.endPacket();
}

void receivePacket() {
  if (!systemSettings.slaveControlEnabled) return;
  
  int packetSize = udp.parsePacket();
  if (packetSize) {
    int len = udp.read(packetBuffer, sizeof(packetBuffer) - 1);
    if (len > 0) {
      packetBuffer[len] = 0; 
      if (strstr(packetBuffer, "\"id\":\"SLV\"") != NULL) {
        lastSlavePacketTime = now;
        slaveKnown = true;
        
        if (currentError == ERR_SLAVE_LOST) {
          currentError = ERR_NONE;
          errorDismissed = false; 
          sendNotification("Slave", "Connection restored");
        }
        watchdogTimer = now;
      }
    }
  }
}

void setRelayState(bool state, const char* source) {
  if (currentError != ERR_NONE) state = false; 
  
  bool changed = (state != relayActive);
  if (changed && (now - lastRelayToggle < 2000)) return; 

  digitalWrite(RELAY_PIN, state ? LOW : HIGH);
  
  if (changed) {
    relayActive = state;
    lastRelayToggle = now;
    playTone(state ? 3000 : 2000, 50);
    
    if (systemSettings.slaveControlEnabled) {
      sendUdpBroadcast();
    }
    
    publishStatus(source);
  }
}

void checkSafety() {
  if (slaveKnown && (now - lastSlavePacketTime > SLAVE_TIMEOUT_MS)) {
    currentError = ERR_SLAVE_LOST;
    setRelayState(false, "SAFETY");
    sendNotification("Safety Alert", "Slave connection lost!");
  }
  
  if (now - watchdogTimer > WATCHDOG_TIMEOUT) {
    watchdogTimer = now;
    ESP.wdtFeed();
  }
}

void runThermostatLogic() {
  checkSafety();
  
  if (!systemEnabled || currentError != ERR_NONE) {
    setRelayState(false, "AUTO");
    return;
  }
  
  bool demand = relayActive;
  
  switch (currentMode) {
    case MODE_HEAT:
      if (temperature <= (targetTemperature - systemSettings.hysteresisLow)) demand = true;
      else if (temperature >= (targetTemperature + systemSettings.hysteresisHigh)) demand = false;
      break;
      
    case MODE_TIMER:
      if (timerEndTime > 0 && now < timerEndTime) {
        demand = true;
      } else {
        demand = false;
        if (timerEndTime > 0 && timerEndTime < now) {
          timerEndTime = 0;
          sendNotification("Timer Complete", "Heating cycle finished");
        }
      }
      break;
      
    case MODE_CYCLE:
      if (cycleActive) {
        if (now < cycleOnEnd) {
          demand = true;
        } else {
          demand = false;
          if (cycleOffEnd == 0) {
            cycleOffEnd = now + (30 * 60 * 1000);
            cycleOnEnd = 0;
          } else if (now >= cycleOffEnd) {
            cycleOnEnd = now + (15 * 60 * 1000);
            cycleOffEnd = 0;
          }
        }
      } else {
        demand = false;
      }
      break;
  }
  
  setRelayState(demand, "AUTO");
}

// ==================== UI RENDER FUNCTIONS ====================
void drawCenteredText(int xOffset, int y, const char* text, const uint8_t* font) {
  display.setFont(font);
  int w = display.getStrWidth(text);
  int x = (128 - w) / 2 + xOffset;
  display.setCursor(x, y);
  display.print(text);
}

void drawCenteredText(int xOffset, int y, const char* text) {
  // Overloaded version with default font
  drawCenteredText(xOffset, y, text, u8g2_font_HelvetiPixel_tr);
}

void drawStatusDot(int x, int y, bool active, bool solid) {
  if (!active) display.drawCircle(x, y, 3);
  else if (solid || (now / 250) % 2 == 0) display.drawDisc(x, y, 3);
  else display.drawCircle(x, y, 3);
}

const char* getModeString() {
  switch (currentMode) {
    case MODE_TIMER: return "TIMER";
    case MODE_CYCLE: return "CYCLE";
    default: return "HEAT";
  }
}

void renderScreen(ScreenId id, int xOffset) {
  if (id == SCREEN_HOME) {
    // Original v16/v17 Home Screen
    display.drawHLine(xOffset, 14, 128);
    
    char statusText[32];
    snprintf(statusText, sizeof(statusText), "%s %s", 
             getModeString(), systemEnabled ? "ON" : "OFF");
    drawCenteredText(xOffset, 11, statusText, u8g2_font_7x13B_mr);
    
    if (relayActive && (now / 250) % 2 == 0) {
      display.drawDisc(xOffset + 120, 7, 3);
    }
    
    char buf[10]; 
    dtostrf((now < targetDisplayTimeout) ? targetTemperature : temperature, 4, 1, buf);
    display.setFont(u8g2_font_fub30_tn);
    int w = display.getStrWidth(buf); 
    int x = (128 - (w + 14)) / 2 + xOffset;
    display.setCursor(x, 56); 
    display.print(buf);
    display.setFont(u8g2_font_HelvetiPixel_tr); 
    display.setCursor(x+w+4, 38); 
    display.print("o"); 
    display.setCursor(x+w+4, 46); 
    display.print("C");
    
    if (currentError != ERR_NONE) {
      drawCenteredText(xOffset, 63, "FAIL-SAFE ENGAGED", u8g2_font_HelvetiPixel_tr);
    } else if (now < targetDisplayTimeout) {
      drawCenteredText(xOffset, 63, "TARGET SETPOINT", u8g2_font_HelvetiPixel_tr);
    } else {
      drawCenteredText(xOffset, 63, "ROOM TEMP", u8g2_font_HelvetiPixel_tr);
    }
  }
  else if (id == SCREEN_NET_LOCAL) {
    // Original Network Local Screen
    display.setDrawColor(1); 
    display.drawBox(xOffset, 0, 128, 14); 
    display.setDrawColor(0);
    drawCenteredText(xOffset, 10, "LOCAL NETWORK", u8g2_font_6x12_tr); 
    display.setDrawColor(1);
    
    display.setFont(u8g2_font_HelvetiPixel_tr); 
    int rowX = xOffset + 15;
    
    drawStatusDot(xOffset + 6, 26, apModeActive, true);
    display.setCursor(rowX, 29); 
    display.print("AP: "); 
    display.print(apSSID);
    
    bool slaveOk = slaveKnown && (now - lastSlavePacketTime < 2000);
    drawStatusDot(xOffset + 6, 38, true, slaveOk);
    display.setCursor(rowX, 41); 
    display.print("Slave: "); 
    display.print(slaveOk ? "Linked" : "Searching...");
    
    int clients = WiFi.softAPgetStationNum(); 
    bool clientConnected = (clients > 0);
    drawStatusDot(xOffset + 6, 50, true, clientConnected);
    display.setCursor(rowX, 53); 
    display.print("Devices: "); 
    display.print(clients);
    
    if (now - lastSlavePacketTime < 200) {
      display.drawDisc(xOffset + 124, 38, 2);
    }
  }
  else if (id == SCREEN_NET_CLOUD) {
    // Original Network Cloud Screen with Settings Access
    display.setDrawColor(1); 
    display.drawBox(xOffset, 0, 128, 14); 
    display.setDrawColor(0);
    drawCenteredText(xOffset, 10, "IOT CLOUD", u8g2_font_6x12_tr); 
    display.setDrawColor(1);
    
    display.setFont(u8g2_font_HelvetiPixel_tr); 
    int rowX = xOffset + 15;
    
    bool wifiOk = (WiFi.status() == WL_CONNECTED);
    drawStatusDot(xOffset + 6, 26, true, wifiOk);
    display.setCursor(rowX, 29); 
    display.print("WiFi: "); 
    if(wifiOk) { 
      String s = WiFi.SSID(); 
      if(s.length() > 10) s = s.substring(0,10) + ".."; 
      display.print(s); 
    } else {
      display.print("Disc.");
    }
    
    bool mqttOk = mqttClient.connected();
    drawStatusDot(xOffset + 6, 38, wifiOk, mqttOk); 
    display.setCursor(rowX, 41); 
    display.print("Server: "); 
    display.print(mqttOk ? "Online" : "Offline");
    
    // Settings access indicator
    drawStatusDot(xOffset + 6, 50, true, true);
    display.setCursor(rowX, 53); 
    display.print("Settings: Press UP");
    
    display.setCursor(xOffset + 4, 60); 
    display.print("IP: "); 
    if(wifiOk) {
      display.print(WiFi.localIP()); 
    } else {
      display.print("---.---.---.---");
    }
  }
  else if (id == SCREEN_SETTINGS_MAIN) {
    // Settings Main Menu
    display.setDrawColor(1); 
    display.drawBox(xOffset, 0, 128, 14); 
    display.setDrawColor(0);
    drawCenteredText(xOffset, 10, "SETTINGS", u8g2_font_6x12_tr); 
    display.setDrawColor(1);
    
    const char* settings[] = {"Buzzer", "Slave Control", "Hysteresis", 
                              "Notifications", "Display", "Back"};
    
    for (int i = 0; i < 6; i++) {
      int y = 20 + i * 8;
      
      // Highlight selected item
      if (i == settingsCursor) {
        display.drawBox(xOffset, y-6, 128, 8);
        display.setDrawColor(0);
      }
      
      display.setFont(u8g2_font_5x7_tr);
      display.setCursor(xOffset + 10, y);
      
      // Draw selection indicator
      if (i == settingsCursor) {
        display.print("> ");
      } else {
        display.print("  ");
      }
      
      display.print(settings[i]);
      display.setDrawColor(1);
    }
    
    // Footer instructions
    display.setCursor(xOffset + 5, 62);
    display.print("SELECT:Enter  UP/DOWN:Nav");
  }
  else if (id == SCREEN_SETTINGS_BUZZER) {
    display.setDrawColor(1); 
    display.drawBox(xOffset, 0, 128, 14); 
    display.setDrawColor(0);
    drawCenteredText(xOffset, 10, "BUZZER", u8g2_font_6x12_tr); 
    display.setDrawColor(1);
    
    display.setFont(u8g2_font_HelvetiPixel_tr);
    drawCenteredText(xOffset, 30, "Status:");
    
    display.setFont(u8g2_font_7x13B_mr);
    if (systemSettings.buzzerEnabled) {
      drawCenteredText(xOffset, 45, "ENABLED", u8g2_font_7x13B_mr);
      // Visual indicator
      if ((now/500)%2) {
        display.drawDisc(xOffset + 64, 55, 4);
      }
    } else {
      drawCenteredText(xOffset, 45, "DISABLED", u8g2_font_7x13B_mr);
      display.drawCircle(xOffset + 64, 55, 4);
    }
    
    display.setFont(u8g2_font_5x7_tr);
    display.setCursor(xOffset + 10, 62);
    display.print("SELECT:Toggle  UP:Back");
  }
  else if (id == SCREEN_SETTINGS_SLAVE) {
    display.setDrawColor(1); 
    display.drawBox(xOffset, 0, 128, 14); 
    display.setDrawColor(0);
    drawCenteredText(xOffset, 10, "SLAVE CONTROL", u8g2_font_6x12_tr); 
    display.setDrawColor(1);
    
    display.setFont(u8g2_font_HelvetiPixel_tr);
    drawCenteredText(xOffset, 30, "Control:");
    
    display.setFont(u8g2_font_7x13B_mr);
    if (systemSettings.slaveControlEnabled) {
      drawCenteredText(xOffset, 45, "ENABLED", u8g2_font_7x13B_mr);
    } else {
      drawCenteredText(xOffset, 45, "DISABLED", u8g2_font_7x13B_mr);
    }
    
    // Connection status
    display.setFont(u8g2_font_5x7_tr);
    if (slaveKnown) {
      drawCenteredText(xOffset, 55, "Slave: CONNECTED", u8g2_font_5x7_tr);
    } else {
      drawCenteredText(xOffset, 55, "Slave: OFFLINE", u8g2_font_5x7_tr);
    }
    
    display.setCursor(xOffset + 10, 62);
    display.print("SELECT:Toggle  UP:Back");
  }
  else if (id == SCREEN_SETTINGS_HYSTERESIS) {
    display.setDrawColor(1); 
    display.drawBox(xOffset, 0, 128, 14); 
    display.setDrawColor(0);
    drawCenteredText(xOffset, 10, "HYSTERESIS", u8g2_font_6x12_tr); 
    display.setDrawColor(1);
    
    display.setFont(u8g2_font_HelvetiPixel_tr);
    
    // Low hysteresis
    display.setCursor(xOffset + 10, 28);
    display.print("Low:");
    display.setCursor(xOffset + 80, 28);
    display.printf("%.1f C", systemSettings.hysteresisLow);
    
    // High hysteresis
    display.setCursor(xOffset + 10, 40);
    display.print("High:");
    display.setCursor(xOffset + 80, 40);
    display.printf("%.1f C", systemSettings.hysteresisHigh);
    
    // Selection indicator
    if (settingsCursor == 0) {
      display.drawTriangle(xOffset + 70, 25, xOffset + 75, 28, xOffset + 70, 31);
    } else {
      display.drawTriangle(xOffset + 70, 37, xOffset + 75, 40, xOffset + 70, 43);
    }
    
    display.setFont(u8g2_font_5x7_tr);
    display.setCursor(xOffset + 10, 62);
    display.print("UP/DOWN:Adjust  SELECT:Switch");
  }
  else if (id == SCREEN_SETTINGS_NOTIFICATIONS) {
    display.setDrawColor(1); 
    display.drawBox(xOffset, 0, 128, 14); 
    display.setDrawColor(0);
    drawCenteredText(xOffset, 10, "NOTIFICATIONS", u8g2_font_6x12_tr); 
    display.setDrawColor(1);
    
    display.setFont(u8g2_font_HelvetiPixel_tr);
    drawCenteredText(xOffset, 30, "MQTT:");
    
    display.setFont(u8g2_font_7x13B_mr);
    if (systemSettings.mqttNotifications) {
      drawCenteredText(xOffset, 45, "ENABLED", u8g2_font_7x13B_mr);
    } else {
      drawCenteredText(xOffset, 45, "DISABLED", u8g2_font_7x13B_mr);
    }
    
    // Server status
    display.setFont(u8g2_font_5x7_tr);
    if (mqttClient.connected()) {
      drawCenteredText(xOffset, 55, "Server: ONLINE", u8g2_font_5x7_tr);
    } else {
      drawCenteredText(xOffset, 55, "Server: OFFLINE", u8g2_font_5x7_tr);
    }
    
    display.setCursor(xOffset + 10, 62);
    display.print("SELECT:Toggle  UP:Back");
  }
  else if (id == SCREEN_SETTINGS_DISPLAY) {
    display.setDrawColor(1); 
    display.drawBox(xOffset, 0, 128, 14); 
    display.setDrawColor(0);
    drawCenteredText(xOffset, 10, "DISPLAY", u8g2_font_6x12_tr); 
    display.setDrawColor(1);
    
    display.setFont(u8g2_font_HelvetiPixel_tr);
    drawCenteredText(xOffset, 28, "Brightness:");
    
    // Brightness bar
    int brightness = map(systemSettings.displayBrightness, 0, 255, 0, 100);
    display.drawFrame(xOffset + 20, 38, 88, 8);
    int fillWidth = (brightness * 86) / 100;
    display.drawBox(xOffset + 21, 39, fillWidth, 6);
    
    // Percentage
    display.setFont(u8g2_font_7x13B_mr);
    char percentStr[8];
    snprintf(percentStr, sizeof(percentStr), "%d%%", brightness);
    drawCenteredText(xOffset, 55, percentStr, u8g2_font_7x13B_mr);
    
    display.setFont(u8g2_font_5x7_tr);
    display.setCursor(xOffset + 10, 62);
    display.print("UP/DOWN:Adjust  SELECT:Back");
  }
  else if (id == SCREEN_INFO) {
    // Original v16/v17 Company Info Screen
    drawCenteredText(xOffset, 18, "HELIOS SYSTEMS", u8g2_font_8x13B_mr);
    display.drawHLine(xOffset + 10, 24, 108);
    display.setFont(u8g2_font_HelvetiPixel_tr);
    drawCenteredText(xOffset, 38, "Firmware v19.0", u8g2_font_HelvetiPixel_tr);
    drawCenteredText(xOffset, 50, "Premium Hybrid UI", u8g2_font_HelvetiPixel_tr);
    drawCenteredText(xOffset, 62, "(c) OrnithDynamics", u8g2_font_HelvetiPixel_tr);
  }
  else if (id == SCREEN_RESET) {
    // Original Reset Screen
    drawCenteredText(xOffset, 12, "! DANGER ZONE !", u8g2_font_7x13B_mr);
    display.drawHLine(xOffset, 16, 128);
    
    if (resetHoldStart > 0) {
      long progress = now - resetHoldStart;
      int width = map(progress, 0, RESET_HOLD_MS, 0, 100); 
      if (width > 100) width = 100;
      
      display.drawFrame(xOffset + 14, 30, 100, 10); 
      display.drawBox(xOffset + 14, 30, width, 10);
      drawCenteredText(xOffset, 55, "HOLD TO WIPE", u8g2_font_HelvetiPixel_tr);
    } else {
      drawCenteredText(xOffset, 35, "Factory Reset?", u8g2_font_6x12_tr);
      drawCenteredText(xOffset, 55, "Hold SELECT 5s", u8g2_font_HelvetiPixel_tr);
    }
  }
  else if (id == SCREEN_RESET_CONFIRM) {
    // Reset Confirmation Screen
    drawCenteredText(xOffset, 12, "CONFIRM RESET", u8g2_font_7x13B_mr);
    display.drawHLine(xOffset, 16, 128);
    
    display.setFont(u8g2_font_HelvetiPixel_tr);
    drawCenteredText(xOffset, 35, "Erase ALL settings?", u8g2_font_HelvetiPixel_tr);
    drawCenteredText(xOffset, 45, "WiFi + System", u8g2_font_HelvetiPixel_tr);
    
    // Yes/No selection
    display.setFont(u8g2_font_7x13B_mr);
    if (selectedOption == OPTION_YES) {
      display.setDrawColor(1);
      display.drawRBox(xOffset + 20, 50, 40, 16, 3);
      display.setDrawColor(0);
      display.setCursor(xOffset + 32, 62);
      display.print("YES");
      display.setDrawColor(1);
      
      display.setCursor(xOffset + 70, 62);
      display.print("NO");
    } else {
      display.setCursor(xOffset + 32, 62);
      display.print("YES");
      
      display.setDrawColor(1);
      display.drawRBox(xOffset + 68, 50, 40, 16, 3);
      display.setDrawColor(0);
      display.setCursor(xOffset + 80, 62);
      display.print("NO");
      display.setDrawColor(1);
    }
    
    display.setFont(u8g2_font_5x7_tr);
    display.setCursor(xOffset + 10, 62);
    display.print("UP/DOWN:Select  SELECT:Confirm");
  }
}

void drawConfirmPopup() {
  // Premium Confirmation Popup
  display.setDrawColor(2);
  display.drawBox(0, 0, 128, 64);
  
  display.setDrawColor(1);
  display.drawRBox(10, 8, 108, 48, 6);
  display.setDrawColor(0);
  display.drawRBox(11, 9, 106, 46, 5);
  display.setDrawColor(1);
  
  display.setFont(u8g2_font_7x13B_mr);
  drawCenteredText(0, 20, pendingRelayState ? "TURN ON?" : "TURN OFF?", u8g2_font_7x13B_mr);
  
  // Selection arrow
  int arrowY = (selectedOption == OPTION_YES) ? 32 : 44;
  
  if ((now / 250) % 2 == 0) {
    display.drawTriangle(18, arrowY, 24, arrowY + 6, 18, arrowY + 12);
  } else {
    display.drawTriangle(20, arrowY, 26, arrowY + 6, 20, arrowY + 12);
  }
  
  // YES option
  if (selectedOption == OPTION_YES) {
    display.setDrawColor(1);
    display.drawRBox(28, 28, 72, 16, 3);
    display.setDrawColor(0);
    display.setCursor(56, 40);
    display.print("YES");
    display.setDrawColor(1);
  } else {
    display.setCursor(56, 40);
    display.print("YES");
  }
  
  // NO option
  if (selectedOption == OPTION_NO) {
    display.setDrawColor(1);
    display.drawRBox(28, 40, 72, 16, 3);
    display.setDrawColor(0);
    display.setCursor(58, 52);
    display.print("NO");
    display.setDrawColor(1);
  } else {
    display.setCursor(58, 52);
    display.print("NO");
  }
  
  display.setFont(u8g2_font_5x7_tr);
  drawCenteredText(0, 60, "UP/DOWN: SELECT  |  SELECT: CONFIRM", u8g2_font_5x7_tr);
}

void updateDisplay() {
  if (currentError == ERR_SLAVE_LOST && !errorDismissed) {
    display.clearBuffer();
    display.setFont(u8g2_font_7x13B_mr);
    drawCenteredText(0, 20, "SAFETY ALERT", u8g2_font_7x13B_mr);
    display.setFont(u8g2_font_HelvetiPixel_tr);
    drawCenteredText(0, 38, "Slave connection lost", u8g2_font_HelvetiPixel_tr);
    drawCenteredText(0, 48, "System disabled", u8g2_font_HelvetiPixel_tr);
    display.sendBuffer();
    return;
  }
  
  display.clearBuffer();
  
  if (isAnimating && currentScreen != targetScreen) {
    if (screenOffset > 0) {
      screenOffset -= 24; 
      renderScreen(currentScreen, screenOffset - 128); 
      renderScreen(targetScreen, screenOffset);
    } else {
      screenOffset += 24;
      renderScreen(currentScreen, screenOffset + 128);
      renderScreen(targetScreen, screenOffset);
    }
    
    if (abs(screenOffset) < 24) { 
      screenOffset = 0; 
      previousScreen = currentScreen;
      currentScreen = targetScreen; 
      isAnimating = false; 
    }
  } else {
    renderScreen(currentScreen, 0);
  }
  
  if (showConfirmPopup) {
    drawConfirmPopup();
  }
  
  display.sendBuffer();
}

// ==================== INPUT HANDLERS ====================
void handleHomeScreenInput() {
  bool sel = digitalRead(BTN_SELECT) == LOW;
  bool up = digitalRead(BTN_UP) == LOW;
  bool down = digitalRead(BTN_DOWN) == LOW;
  
  // SHORT SELECT: Enter Network Local Screen
  if (sel && !longPressTriggered) {
    if (selectPressStart == 0) selectPressStart = now;
  } else if (!sel && selectPressStart > 0 && !longPressTriggered) {
    if (now - selectPressStart < 300) { // Short press
      navigateTo(SCREEN_NET_LOCAL);
      playTone(500, 30);
    }
    selectPressStart = 0;
  }
  
  // UP/DOWN: Adjust Temperature
  if (now - lastTempAdjustTime > 150) { 
    if (up || down) {
      if (systemEnabled) {
        float potentialTarget = targetTemperature + (up ? 0.5 : -0.5);
        bool nextRelayState = relayActive;
        
        if (temperature <= (potentialTarget - systemSettings.hysteresisLow)) nextRelayState = true;
        else if (temperature >= (potentialTarget + systemSettings.hysteresisHigh)) nextRelayState = false;
        
        if (nextRelayState != relayActive) {
          pendingTargetTemp = potentialTarget; 
          pendingRelayState = nextRelayState;
          showConfirmPopup = true;
          selectedOption = OPTION_YES;
          playTone(1200, 100);
        } else {
          targetTemperature = potentialTarget; 
          targetDisplayTimeout = now + 1500;
          playTone(600, 50);
        }
      } else {
        if(up) targetTemperature += 0.5; 
        else targetTemperature -= 0.5;
        targetDisplayTimeout = now + 1500;
        playTone(600, 50);
      }
      lastTempAdjustTime = now;
    }
  }
  
  // LONG PRESS: Toggle System Power
  if (sel) {
    if (selectPressStart == 0) selectPressStart = now;
    
    if (!longPressTriggered && (now - selectPressStart > LONG_PRESS_MS)) {
      longPressTriggered = true;
      systemEnabled = !systemEnabled;
      playTone(2000, 100); 
      delay(100); 
      playTone(3000, 100);
      publishStatus("MANUAL_OVERRIDE"); 
      sendNotification("Power", systemEnabled ? "Manual ON" : "Manual OFF");
    }
  } else {
    if (selectPressStart > 0) selectPressStart = 0;
    longPressTriggered = false;
  }
}

void handleNetworkScreensInput() {
  bool sel = digitalRead(BTN_SELECT) == LOW;
  bool up = digitalRead(BTN_UP) == LOW;
  bool down = digitalRead(BTN_DOWN) == LOW;
  
  // SELECT: Go back to Home
  if (sel && !buttonHandled) {
    buttonHandled = true;
    navigateTo(SCREEN_HOME, NAV_LEFT);
    playTone(400, 30);
    return;
  }
  
  // UP/DOWN: Navigate between Network screens
  if (now - lastTempAdjustTime > 200) {
    if (up && !buttonHandled) {
      buttonHandled = true;
      if (currentScreen == SCREEN_NET_LOCAL) {
        navigateTo(SCREEN_NET_CLOUD, NAV_RIGHT);
      } else if (currentScreen == SCREEN_NET_CLOUD) {
        navigateTo(SCREEN_INFO, NAV_RIGHT);
      } else if (currentScreen == SCREEN_INFO) {
        navigateTo(SCREEN_RESET, NAV_RIGHT);
      } else if (currentScreen == SCREEN_RESET) {
        navigateTo(SCREEN_NET_LOCAL, NAV_RIGHT);
      }
      lastTempAdjustTime = now;
      playTone(500, 30);
    } else if (down && !buttonHandled) {
      buttonHandled = true;
      if (currentScreen == SCREEN_NET_LOCAL) {
        navigateTo(SCREEN_RESET, NAV_LEFT);
      } else if (currentScreen == SCREEN_NET_CLOUD) {
        navigateTo(SCREEN_NET_LOCAL, NAV_LEFT);
      } else if (currentScreen == SCREEN_INFO) {
        navigateTo(SCREEN_NET_CLOUD, NAV_LEFT);
      } else if (currentScreen == SCREEN_RESET) {
        navigateTo(SCREEN_INFO, NAV_LEFT);
      }
      lastTempAdjustTime = now;
      playTone(500, 30);
    }
  }
  
  // Special: UP in NET_CLOUD enters Settings
  if (currentScreen == SCREEN_NET_CLOUD && up && !buttonHandled) {
    buttonHandled = true;
    navigateTo(SCREEN_SETTINGS_MAIN, NAV_RIGHT);
    playTone(800, 50);
    return; // Important: prevent double handling
  }
  
  // Reset screen special handling
  if (currentScreen == SCREEN_RESET) {
    if (sel) {
      if (resetHoldStart == 0) resetHoldStart = now;
      
      if (now - resetHoldStart > RESET_HOLD_MS) {
        navigateTo(SCREEN_RESET_CONFIRM, NAV_RIGHT);
        resetHoldStart = 0;
        playTone(3000, 100);
      }
    } else {
      resetHoldStart = 0;
    }
  }
  
  if (!sel && !up && !down) {
    buttonHandled = false;
  }
}

void handleSettingsInput() {
  bool sel = digitalRead(BTN_SELECT) == LOW;
  bool up = digitalRead(BTN_UP) == LOW;
  bool down = digitalRead(BTN_DOWN) == LOW;
  
  if (inSettingsSubMenu) {
    // Handle sub-menu input
    switch(currentScreen) {
      case SCREEN_SETTINGS_BUZZER:
        if (sel && !buttonHandled) {
          buttonHandled = true;
          systemSettings.buzzerEnabled = !systemSettings.buzzerEnabled;
          saveSystemSettings();
          playTone(systemSettings.buzzerEnabled ? 2000 : 500, 100);
        }
        break;
        
      case SCREEN_SETTINGS_SLAVE:
        if (sel && !buttonHandled) {
          buttonHandled = true;
          systemSettings.slaveControlEnabled = !systemSettings.slaveControlEnabled;
          saveSystemSettings();
          playTone(1500, 100);
          sendNotification("Slave Control", systemSettings.slaveControlEnabled ? "Enabled" : "Disabled");
        }
        break;
        
      case SCREEN_SETTINGS_HYSTERESIS:
        if (now - lastTempAdjustTime > 150) {
          if (up && !buttonHandled) {
            buttonHandled = true;
            if (settingsCursor == 0) systemSettings.hysteresisLow += 0.1;
            else systemSettings.hysteresisHigh += 0.1;
            saveSystemSettings();
            lastTempAdjustTime = now;
            playTone(800, 50);
          } else if (down && !buttonHandled) {
            buttonHandled = true;
            if (settingsCursor == 0) {
              systemSettings.hysteresisLow = max(0.1f, systemSettings.hysteresisLow - 0.1f);
            } else {
              systemSettings.hysteresisHigh = max(0.1f, systemSettings.hysteresisHigh - 0.1f);
            }
            saveSystemSettings();
            lastTempAdjustTime = now;
            playTone(600, 50);
          }
        }
        if (sel && !buttonHandled) {
          buttonHandled = true;
          settingsCursor = (settingsCursor + 1) % 2;
          playTone(1000, 50);
        }
        break;
        
      case SCREEN_SETTINGS_NOTIFICATIONS:
        if (sel && !buttonHandled) {
          buttonHandled = true;
          systemSettings.mqttNotifications = !systemSettings.mqttNotifications;
          saveSystemSettings();
          playTone(systemSettings.mqttNotifications ? 1800 : 700, 100);
          sendNotification("Notifications", systemSettings.mqttNotifications ? "Enabled" : "Disabled");
        }
        break;
        
      case SCREEN_SETTINGS_DISPLAY:
        if (now - lastTempAdjustTime > 150) {
          if (up && !buttonHandled) {
            buttonHandled = true;
            systemSettings.displayBrightness = min(255, systemSettings.displayBrightness + 15);
            saveSystemSettings();
            display.setContrast(systemSettings.displayBrightness);
            lastTempAdjustTime = now;
            playTone(900, 30);
          } else if (down && !buttonHandled) {
            buttonHandled = true;
            systemSettings.displayBrightness = max(30, systemSettings.displayBrightness - 15);
            saveSystemSettings();
            display.setContrast(systemSettings.displayBrightness);
            lastTempAdjustTime = now;
            playTone(700, 30);
          }
        }
        break;
    }
    
    // UP button in any sub-menu goes back
    if (up && !buttonHandled && currentScreen != SCREEN_SETTINGS_HYSTERESIS) {
      buttonHandled = true;
      navigateBack();
      playTone(400, 30);
    }
    
  } else {
    // Main settings menu navigation
    if (up && !buttonHandled && now - lastTempAdjustTime > 200) {
      buttonHandled = true;
      settingsCursor = (settingsCursor - 1 + 6) % 6;
      lastTempAdjustTime = now;
      playTone(500, 30);
    } else if (down && !buttonHandled && now - lastTempAdjustTime > 200) {
      buttonHandled = true;
      settingsCursor = (settingsCursor + 1) % 6;
      lastTempAdjustTime = now;
      playTone(500, 30);
    } else if (sel && !buttonHandled) {
      buttonHandled = true;
      
      if (settingsCursor == 5) { // "Back" option
        navigateBack();
        playTone(400, 30);
      } else {
        // Enter selected sub-menu
        inSettingsSubMenu = true;
        ScreenId target;
        switch(settingsCursor) {
          case 0: target = SCREEN_SETTINGS_BUZZER; break;
          case 1: target = SCREEN_SETTINGS_SLAVE; break;
          case 2: target = SCREEN_SETTINGS_HYSTERESIS; break;
          case 3: target = SCREEN_SETTINGS_NOTIFICATIONS; break;
          case 4: target = SCREEN_SETTINGS_DISPLAY; break;
          default: target = SCREEN_SETTINGS_MAIN;
        }
        navigateTo(target, NAV_RIGHT);
        playTone(800, 50);
      }
    }
  }
  
  if (!sel && !up && !down) {
    buttonHandled = false;
  }
}

void handleResetConfirmInput() {
  bool sel = digitalRead(BTN_SELECT) == LOW;
  bool up = digitalRead(BTN_UP) == LOW;
  bool down = digitalRead(BTN_DOWN) == LOW;
  
  // UP/DOWN: Toggle selection
  if ((up || down) && !buttonHandled) {
    buttonHandled = true;
    selectedOption = (selectedOption == OPTION_YES) ? OPTION_NO : OPTION_YES;
    playTone(700, 50);
  }
  
  // SELECT: Confirm choice
  if (sel && !buttonHandled) {
    buttonHandled = true;
    playTone(1500, 100);
    
    if (selectedOption == OPTION_YES) {
      // Perform factory reset
      playTone(3000, 1000);
      
      // Clear WiFi settings
      WifiSettings empty;
      empty.magic = 0;
      EEPROM.put(0, empty);
      
      // Clear system settings
      systemSettings.magic = 0;
      EEPROM.put(100, systemSettings);
      
      EEPROM.commit();
      delay(1000);
      ESP.restart();
    } else {
      // Cancel reset
      navigateTo(SCREEN_RESET, NAV_LEFT);
      playTone(500, 200);
    }
  }
  
  if (!sel && !up && !down) {
    buttonHandled = false;
  }
}

void handleInput() {
  if (now - t_input < BUTTON_DEBOUNCE_MS) return;
  t_input = now;
  
  // Handle confirmation popup first
  if (showConfirmPopup) {
    bool sel = digitalRead(BTN_SELECT) == LOW;
    bool up = digitalRead(BTN_UP) == LOW;
    bool down = digitalRead(BTN_DOWN) == LOW;
    
    if (sel && !buttonHandled) {
      buttonHandled = true;
      playTone(1500, 100);
      
      if (selectedOption == OPTION_YES) {
        targetTemperature = pendingTargetTemp;
        targetDisplayTimeout = now + 1500;
        showConfirmPopup = false;
        playTone(3000, 200);
      } else {
        showConfirmPopup = false;
        playTone(500, 200);
      }
      return;
    }
    
    if (up && !buttonHandled) {
      buttonHandled = true;
      if (selectedOption != OPTION_YES) {
        selectedOption = OPTION_YES;
        lastScrollTime = now;
        playTone(800, 50);
      }
      return;
    }
    
    if (down && !buttonHandled) {
      buttonHandled = true;
      if (selectedOption != OPTION_NO) {
        selectedOption = OPTION_NO;
        lastScrollTime = now;
        playTone(600, 50);
      }
      return;
    }
    
    if (!sel && !up && !down) {
      buttonHandled = false;
    }
    return;
  }
  
  // Route to appropriate handler based on current screen
  switch(currentScreen) {
    case SCREEN_HOME:
      handleHomeScreenInput();
      break;
      
    case SCREEN_NET_LOCAL:
    case SCREEN_NET_CLOUD:
    case SCREEN_INFO:
    case SCREEN_RESET:
      handleNetworkScreensInput();
      break;
      
    case SCREEN_SETTINGS_MAIN:
    case SCREEN_SETTINGS_BUZZER:
    case SCREEN_SETTINGS_SLAVE:
    case SCREEN_SETTINGS_HYSTERESIS:
    case SCREEN_SETTINGS_NOTIFICATIONS:
    case SCREEN_SETTINGS_DISPLAY:
      handleSettingsInput();
      break;
      
    case SCREEN_RESET_CONFIRM:
      handleResetConfirmInput();
      break;
  }
}

// ==================== SETUP & MAIN LOOP ====================
void setup() {
  #ifdef SERIAL_DEBUG
    Serial.begin(115200);
    delay(100);
    DEBUG_PRINTLN("Helios Master v19.0 - Hybrid Navigation");
  #endif
  
  // Initialize hardware
  pinMode(RELAY_PIN, OUTPUT); 
  digitalWrite(RELAY_PIN, HIGH);
  pinMode(BUZZER_PIN, OUTPUT); 
  digitalWrite(BUZZER_PIN, LOW);
  pinMode(BTN_UP, INPUT_PULLUP);
  pinMode(BTN_DOWN, INPUT_PULLUP);
  pinMode(BTN_SELECT, INPUT_PULLUP);

  // Initialize EEPROM and settings
  EEPROM.begin(512);
  EEPROM.get(0, wifiCreds);
  loadSystemSettings();
  
  systemStartTime = millis();

  // Initialize display
  display.begin();
  display.setContrast(systemSettings.displayBrightness);
  display.clearBuffer();
  drawCenteredText(0, 38, "HELIOS SYSTEMS", u8g2_font_bpixeldouble_tr);
  display.sendBuffer();
  
  playStartupSound();
  
  // Initialize sensor
  if (!aht.begin()) {
    currentError = ERR_SENSOR_FAIL;
    DEBUG_PRINTLN("AHT Sensor not found!");
  }

  // Initialize network
  WiFi.mode(WIFI_AP_STA);
  WiFi.softAP(apSSID, apPass);
  
  if (wifiCreds.magic == 0x55) {
    DEBUG_PRINTF("Connecting to saved WiFi: %s\n", wifiCreds.ssid);
    WiFi.begin(wifiCreds.ssid, wifiCreds.pass);
  }

  espClient.setInsecure();
  mqttClient.setServer(mqtt_server, mqtt_port);
  mqttClient.setCallback(mqttCallback);
  mqttClient.setKeepAlive(30);
  mqttClient.setSocketTimeout(10);

  udp.begin(udpPort);
  
  // Initialize web server
  server.on("/", [](){ 
    server.send_P(200, "text/html", INDEX_HTML); 
  });
  server.on("/scan", handleScan);
  server.on("/save_wifi", HTTP_POST, handleSaveWifi);
  server.on("/api/command", HTTP_POST, handleApiCommand);
  server.on("/api/status", HTTP_GET, handleApiStatus);
  
  // Initialize OTA
  ArduinoOTA.setHostname("Helios-Master-19");
  ArduinoOTA.setPassword("admin");
  httpUpdater.setup(&server, "/update", "admin", "admin");
  
  MDNS.begin("helios-19");
  ArduinoOTA.begin();
  server.begin();

  watchdogTimer = millis();
  
  DEBUG_PRINTLN("Setup Complete");
}

void loop() {
  now = millis();
  ESP.wdtFeed();

  // Handle OTA and web server
  ArduinoOTA.handle();
  server.handleClient();
  mqttClient.loop();

  // Startup sequence
  if (!startupApLaunched && now > 3000) { 
    startupApLaunched = true; 
    toggleAPMode(true); 
    playTone(2000, 50); 
    sendNotification("System", "Helios Master v19.0 Online");
  }

  // Network communication
  if (apModeActive) { 
    receivePacket(); 
    if (now - t_heartbeat > HEARTBEAT_MS) { 
      t_heartbeat = now; 
      if (systemSettings.slaveControlEnabled) sendUdpBroadcast(); 
    }
  }
  
  // Internet and MQTT management
  if (now - t_internet > INTERNET_CHECK_MS) {
    t_internet = now;
    bool wifiOk = (WiFi.status() == WL_CONNECTED);
    internetAvailable = wifiOk ? probeInternet() : false;
    if (internetAvailable && !mqttClient.connected()) connectMqtt();
  }

  if (!mqttClient.connected()) connectMqtt();

  // Thermostat logic
  runThermostatLogic();

  // Sensor reading
  if (now - t_sensor > SENSOR_READ_MS) {
    t_sensor = now;
    sensors_event_t h, t;
    
    if (aht.getEvent(&h, &t)) {
      temperature = t.temperature;
      humidity = h.relative_humidity;
      
      if (now - lastStatusPublish > 10000) {
        lastStatusPublish = now;
        publishStatus("PERIODIC");
      }
    } else if (currentError == ERR_NONE) {
      currentError = ERR_SENSOR_FAIL;
    }
  }
  
  // Handle user input
  handleInput();

  // Update display
  if (now - t_display > DISPLAY_UPDATE_MS) {
    t_display = now;
    updateDisplay();
  }
}




/* 
 * HELIOS Master Firmware - v19.1 (UI Refinement & Full Network Transparency)
 * 
 * CHANGE LOG v19.0:
 * - ENHANCED: JSON payload now includes distinct "ap_ip" and "router_ip" for the App.
 * - FIXED: "Select" button press in Popup/Alert no longer leaks into Menu Navigation logic.
 * - REDESIGNED: "Link Lost" Alert screen now uses the Premium Popup design (Rounded box, clean style).
 * - PRESERVED: All existing screens and logic remain untouched.
 * 
 * CORE FEATURES:
 * - Master-Slave UDP Coordination
 * - Premium Confirmation UI with List Selection
 * - Full App Compatibility (MQTT + Local API)
 * - Network Transparency (AP & Router IPs communicated)
 * - Robust Input Handling (State Leak Prevention)
 */

#include <Arduino.h>
#include <Wire.h>
#include <U8g2lib.h>
#include <Adafruit_AHTX0.h>
#include <ESP.h>
#include <ESP8266WiFi.h>
#include <ESP8266WebServer.h>
#include <WiFiUdp.h>
#include <EEPROM.h>
#include <PubSubClient.h>
#include <ArduinoJson.h>
#include <ESP8266mDNS.h>
#include <ArduinoOTA.h>
#include <ESP8266HTTPUpdateServer.h>

// ==================== DEBUG CONFIGURATION ====================
// #define SERIAL_DEBUG
#ifdef SERIAL_DEBUG
  #define DEBUG_PRINT(x) Serial.print(x)
  #define DEBUG_PRINTLN(x) Serial.println(x)
  #define DEBUG_PRINTF(...) Serial.printf(__VA_ARGS__)
#else
  #define DEBUG_PRINT(x)
  #define DEBUG_PRINTLN(x)
  #define DEBUG_PRINTF(...)
#endif

// ==================== HARDWARE CONFIGURATION ====================
#define RELAY_PIN   D0 
#define BTN_UP      D5 
#define BTN_DOWN    D6 
#define BTN_SELECT  D7 
#define BUZZER_PIN  D8 
#define SDA_PIN     D2 
#define SCL_PIN     D1 

// --- System Timings ---
#define DISPLAY_UPDATE_MS     33
#define SENSOR_READ_MS        2000
#define HEARTBEAT_MS          1000
#define SLAVE_TIMEOUT_MS      45000
#define MQTT_RECONNECT_MS     5000
#define RESET_HOLD_MS         5000
#define RESET_DEBOUNCE_MS     300
#define LONG_PRESS_MS         1000
#define WATCHDOG_TIMEOUT      30000
#define SCROLL_ANIMATION_MS   150
#define INTERNET_CHECK_MS     10000

// --- MQTT Configuration ---
const char* mqtt_server = "2029c2a3fad64b4185467bdeb78ad7c1.s1.eu.hivemq.cloud";
const int mqtt_port = 8883;
const char* mqtt_user = "Helios";
const char* mqtt_pass = "88v3dzsE";
const char* topic_status = "followers/status";
const char* topic_cmd    = "helios/cmd";
const char* topic_notifications = "helios/notifications";

// ==================== OBJECTS ====================
U8G2_SSD1306_128X64_NONAME_F_HW_I2C display(U8G2_R0, U8X8_PIN_NONE, SCL_PIN, SDA_PIN);
Adafruit_AHTX0 aht;
ESP8266WebServer server(80);
WiFiUDP udp;
WiFiClientSecure espClient;
PubSubClient mqttClient(espClient);
ESP8266HTTPUpdateServer httpUpdater;

// ==================== STATE STRUCTURES ====================
struct WifiSettings { 
  char ssid[32]; 
  char pass[32]; 
  uint8_t magic;
};
WifiSettings wifiCreds;

enum SystemMode { MODE_HEAT = 0, MODE_TIMER = 1, MODE_CYCLE = 2 };
enum SystemError { ERR_NONE = 0, ERR_SLAVE_LOST = 1, ERR_SENSOR_FAIL = 2, ERR_WIFI_LOST = 3 };
enum ScreenId { 
  SCREEN_HOME, 
  SCREEN_NET_LOCAL, 
  SCREEN_NET_CLOUD, 
  SCREEN_INFO, 
  SCREEN_IPS,       
  SCREEN_AP_CREDS,  
  SCREEN_RESET, 
  SCREEN_COUNT 
};
enum ConfirmationOption { OPTION_YES = 0, OPTION_NO = 1 };

// ==================== GLOBAL STATE VARIABLES ====================
float temperature = 0.0;
float humidity = 0.0;
bool relayActive = false;
bool systemEnabled = false;
SystemMode currentMode = MODE_HEAT;
float targetTemperature = 22.0;
const float HYSTERESIS_LOW = 0.3;
const float HYSTERESIS_HIGH = 0.1;

unsigned long timerEndTime = 0;
unsigned long cycleOnEnd = 0;
unsigned long cycleOffEnd = 0;
bool cycleActive = false;

float pendingTargetTemp = 0.0;
bool pendingRelayState = false;
bool showConfirmPopup = false;
ConfirmationOption selectedOption = OPTION_YES;
int optionScrollOffset = 0;
unsigned long lastScrollTime = 0;

bool apModeActive = false; 
bool startupApLaunched = false;
bool internetAvailable = false;
const char* apSSID = "HELIOS_MASTER";
const char* apPass = "12345678";
const int udpPort = 4210;
char packetBuffer[64];

unsigned long lastSlavePacketTime = 0;
bool slaveKnown = false; 
SystemError currentError = ERR_NONE;
bool errorDismissed = false;
unsigned long watchdogTimer = 0;

ScreenId currentScreen = SCREEN_HOME;
ScreenId targetScreen = SCREEN_HOME;
int screenOffset = 0; 
bool isAnimating = false;

unsigned long selectPressStart = 0, upPressStart = 0, downPressStart = 0;
bool longPressTriggered = false;
unsigned long resetHoldStart = 0; 
bool buttonHandled = false;

unsigned long now = 0;
unsigned long t_display = 0, t_sensor = 0, t_heartbeat = 0, t_internet = 0;
unsigned long t_input = 0, t_mqtt_retry = 0;
unsigned long targetDisplayTimeout = 0, lastRelayToggle = 0, lastTempAdjustTime = 0;
unsigned long lastStatusPublish = 0;

// ==================== WEB UI ====================
const char INDEX_HTML[] PROGMEM = R"rawliteral(
<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><title>Helios Systems</title>
<style>:root{--bg:#121212;--c:#1e1e1e;--t:#e0e0e0;--a:#00e676}body{background:var(--bg);color:var(--t);font-family:sans-serif;padding:20px;text-align:center}
.card{background:var(--c);border-radius:12px;padding:20px;margin-bottom:15px}h1{color:var(--a);margin:0}textarea{width:100%;background:#000;color:var(--a);border:1px solid #333;padding:10px}
</style></head><body><div class="card"><h1>Helios Systems</h1><p>Master Hub v19.0</p></div>
<div class="card"><h3>Slave Credentials</h3><textarea readonly onclick="this.select()">{"role":"SLAVE","ssid":"HELIOS_MASTER","pass":"12345678","relay_pin":2,"led_pin":1,"sensors":false}</textarea></div>
<div class="card"><h3>Firmware Update</h3><a href="/update"><button>Upload Firmware</button></a></div>
</body></html>
)rawliteral";

// ==================== UTILITY FUNCTIONS ====================
void playTone(int freq, int duration) {
  tone(BUZZER_PIN, freq, duration);
}

void playStartupSound() {
  int melody[] = { 262, 330, 392, 523 }; 
  for (int i = 0; i < 4; i++) {
    playTone(melody[i], 100); 
    delay(120); 
    noTone(BUZZER_PIN);
  }
}

void toggleAPMode(bool enable) {
  apModeActive = enable;
  if (enable) {
    WiFi.mode(WIFI_AP_STA);
    WiFi.softAP(apSSID, apPass);
    udp.begin(udpPort);
    server.begin();
  } else {
    server.stop();
    udp.stop();
    WiFi.enableAP(false);
  }
}

bool probeInternet() {
  IPAddress ip;
  const char* host = "clients3.google.com";
  const int port = 80;
  if (!WiFi.hostByName(host, ip)) return false;
  
  WiFiClient client;
  if (!client.connect(ip, port)) return false;
  
  client.print(String("GET /generate_204 HTTP/1.1\r\nHost: ") + host + "\r\nConnection: close\r\n\r\n");
  unsigned long start = millis();
  while (!client.available()) {
    if (millis() - start > 1200) { client.stop(); return false; }
  }
  String line = client.readStringUntil('\r');
  client.stop();
  return (line.indexOf("204") >= 0 || line.indexOf("200") >= 0);
}

void sendNotification(const char* title, const char* message) {
  if (!mqttClient.connected()) return;
  char notif[128];
  snprintf(notif, sizeof(notif), "{\"title\":\"%s\",\"message\":\"%s\"}", title, message);
  mqttClient.publish(topic_notifications, notif);
}

// UPDATED: Includes separate AP and Router IPs
void publishStatus(const char* trigger) {
  if (!mqttClient.connected()) return;
  
  char msg[512]; // Increased buffer for JSON
  String routerIP = (WiFi.status() == WL_CONNECTED) ? WiFi.localIP().toString() : "0.0.0.0";
  String apIP = WiFi.softAPIP().toString();
  
  StaticJsonDocument<512> doc;
  doc["relay"] = relayActive;
  doc["temp"] = temperature;
  doc["target"] = targetTemperature;
  doc["humidity"] = humidity;
  doc["trigger"] = trigger;
  doc["mode"] = (int)currentMode;
  doc["enabled"] = systemEnabled;
  doc["router_ip"] = routerIP;
  doc["ap_ip"] = apIP;
  
  serializeJson(doc, msg);
  mqttClient.publish(topic_status, msg);
}

void processCommand(const char* jsonPayload, const char* source) {
  StaticJsonDocument<512> doc;
  DeserializationError err = deserializeJson(doc, jsonPayload);
  
  if (err) {
    DEBUG_PRINTLN("JSON Parse Error");
    return;
  }

  if (doc.containsKey("type")) {
    const char* type = doc["type"];
    
    if (strcmp(type, "set_power") == 0) {
      bool value = doc["value"] | false;
      systemEnabled = value;
      if (!systemEnabled) setRelayState(false, "APP_CMD");
      publishStatus("APP_POWER");
      sendNotification("Power", systemEnabled ? "System ON" : "System OFF");
    }
    else if (strcmp(type, "set_target") == 0) {
      float value = doc["value"] | 22.0;
      targetTemperature = value;
      targetDisplayTimeout = now + 1500;
      publishStatus("APP_TARGET");
    }
    else if (strcmp(type, "set_mode") == 0) {
      const char* value = doc["value"];
      if (strcmp(value, "timer") == 0) {
        currentMode = MODE_TIMER;
        sendNotification("Mode", "Timer mode activated");
      } else if (strcmp(value, "cycle") == 0) {
        currentMode = MODE_CYCLE;
        sendNotification("Mode", "Cycle mode activated");
      } else {
        currentMode = MODE_HEAT;
        sendNotification("Mode", "Heat mode activated");
      }
      publishStatus("APP_MODE");
    }
    else if (strcmp(type, "set_timer") == 0) {
      unsigned long seconds = doc["seconds"] | 0;
      timerEndTime = now + (seconds * 1000);
      currentMode = MODE_TIMER;
      systemEnabled = true;
      char timerMsg[50];
      snprintf(timerMsg, sizeof(timerMsg), "%lu min timer started", seconds / 60);
      sendNotification("Timer Set", timerMsg);
      publishStatus("APP_TIMER");
    }
    else if (strcmp(type, "set_cycle") == 0) {
      unsigned long onSec = doc["on_sec"] | 0;
      unsigned long offSec = doc["off_sec"] | 0;
      cycleOnEnd = now + (onSec * 1000);
      cycleOffEnd = 0;
      cycleActive = true;
      currentMode = MODE_CYCLE;
      systemEnabled = true;
      char cycleMsg[80];
      snprintf(cycleMsg, sizeof(cycleMsg), "%lu min ON, %lu min OFF", onSec / 60, offSec / 60);
      sendNotification("Cycle Set", cycleMsg);
      publishStatus("APP_CYCLE");
    }
    else if (strcmp(type, "set_wifi") == 0) {
      const char* ssid = doc["ssid"];
      const char* pass = doc["pass"];
      if (ssid && pass && strlen(ssid) > 0) {
        strlcpy(wifiCreds.ssid, ssid, sizeof(wifiCreds.ssid));
        strlcpy(wifiCreds.pass, pass, sizeof(wifiCreds.pass));
        wifiCreds.magic = 0x55;
        EEPROM.put(0, wifiCreds);
        EEPROM.commit();
        char wifiMsg[70];
        snprintf(wifiMsg, sizeof(wifiMsg), "Connecting to %s", wifiCreds.ssid);
        sendNotification("WiFi Updated", wifiMsg);
        delay(1000);
        ESP.restart();
      }
    }
  }
}

void mqttCallback(char* topic, byte* payload, unsigned int length) {
  payload[length] = '\0';
  String message = String((char*)payload);
  processCommand(message.c_str(), "MQTT");
}

void connectMqtt() {
  if (WiFi.status() != WL_CONNECTED) return;
  
  if (now - t_mqtt_retry > MQTT_RECONNECT_MS) {
    t_mqtt_retry = now;
    String clientId = "Helios-" + String(random(0xffff), HEX);
    
    if (mqttClient.connect(clientId.c_str(), mqtt_user, mqtt_pass)) {
      mqttClient.subscribe(topic_cmd);
      publishStatus("RECONNECT");
      sendNotification("System", "MQTT Connected");
    }
  }
}

void handleScan() {
  int n = WiFi.scanNetworks();
  String json = "[";
  for (int i = 0; i < n; ++i) {
    if (i) json += ",";
    json += "\"" + WiFi.SSID(i) + "\"";
  }
  json += "]";
  server.send(200, "application/json", json);
}

void handleSaveWifi() {
  if (server.hasArg("plain")) {
    StaticJsonDocument<128> doc;
    DeserializationError err = deserializeJson(doc, server.arg("plain"));
    if (!err) {
      if(doc.containsKey("ssid")) strlcpy(wifiCreds.ssid, doc["ssid"] | "", sizeof(wifiCreds.ssid));
      if(doc.containsKey("pass")) strlcpy(wifiCreds.pass, doc["pass"] | "", sizeof(wifiCreds.pass));
      
      if (strlen(wifiCreds.ssid) > 0) {
        wifiCreds.magic = 0x55;
        EEPROM.put(0, wifiCreds);
        EEPROM.commit();
        server.send(200, "application/json", "{\"status\":\"saved\"}");
        delay(500);
        ESP.restart();
        return;
      }
    }
  }
  server.send(400, "application/json", "{\"status\":\"error\"}");
}

void handleCorsHeaders() {
  server.sendHeader("Access-Control-Allow-Origin", "*");
  server.sendHeader("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
  server.sendHeader("Access-Control-Allow-Headers", "Content-Type");
}

void handleApiCommand() {
  handleCorsHeaders();
  if (server.hasArg("plain")) {
    processCommand(server.arg("plain").c_str(), "API");
    server.send(200, "application/json", "{\"status\":\"ok\"}");
  } else {
    server.send(400, "application/json", "{\"status\":\"no_data\"}");
  }
}

// UPDATED: Includes AP and Router IPs in response
void handleApiStatus() {
  handleCorsHeaders();
  StaticJsonDocument<512> doc;
  
  String routerIP = (WiFi.status() == WL_CONNECTED) ? WiFi.localIP().toString() : "0.0.0.0";
  String apIP = WiFi.softAPIP().toString();

  doc["relay"] = relayActive;
  doc["temp"] = temperature;
  doc["target"] = targetTemperature;
  doc["humidity"] = humidity;
  doc["mode"] = (int)currentMode;
  doc["enabled"] = systemEnabled;
  doc["router_ip"] = routerIP;
  doc["ap_ip"] = apIP;

  String msg;
  serializeJson(doc, msg);
  server.send(200, "application/json", msg);
}

void sendUdpBroadcast() {
  char msg[64];
  bool safeState = (currentError == ERR_NONE) ? relayActive : false;
  snprintf(msg, sizeof(msg), "{\"id\":\"MST\",\"relay\":%s}", safeState ? "true" : "false");
  
  IPAddress broadcastIp = WiFi.softAPIP();
  broadcastIp[3] = 255; 
  udp.beginPacket(broadcastIp, udpPort);
  udp.write(msg);
  udp.endPacket();
}

void receivePacket() {
  int packetSize = udp.parsePacket();
  if (packetSize) {
    int len = udp.read(packetBuffer, sizeof(packetBuffer) - 1);
    if (len > 0) {
      packetBuffer[len] = 0; 
      if (strstr(packetBuffer, "\"id\":\"SLV\"") != NULL) {
        lastSlavePacketTime = now;
        slaveKnown = true;
        if (currentError == ERR_SLAVE_LOST) {
          currentError = ERR_NONE;
          errorDismissed = false; 
          sendNotification("Slave", "Connection restored");
        }
        watchdogTimer = now;
      }
    }
  }
}

void setRelayState(bool state, const char* source) {
  if (currentError != ERR_NONE) state = false; 
  
  bool changed = (state != relayActive);
  if (changed && (now - lastRelayToggle < 2000)) return; 

  digitalWrite(RELAY_PIN, state ? LOW : HIGH);
  
  if (changed) {
    relayActive = state;
    lastRelayToggle = now;
    playTone(state ? 3000 : 2000, 50);
    sendUdpBroadcast(); 
    publishStatus(source);
  }
}

void checkSafety() {
  if (slaveKnown && (now - lastSlavePacketTime > SLAVE_TIMEOUT_MS)) {
    currentError = ERR_SLAVE_LOST;
    setRelayState(false, "SAFETY");
    sendNotification("Safety Alert", "Slave connection lost!");
  }
  
  if (now - watchdogTimer > WATCHDOG_TIMEOUT) {
    watchdogTimer = now;
    ESP.wdtFeed();
  }
}

void runThermostatLogic() {
  checkSafety();
  
  if (!systemEnabled || currentError != ERR_NONE) {
    setRelayState(false, "AUTO");
    return;
  }
  
  bool demand = relayActive;
  
  switch (currentMode) {
    case MODE_HEAT:
      if (temperature <= (targetTemperature - HYSTERESIS_LOW)) demand = true;
      else if (temperature >= (targetTemperature + HYSTERESIS_HIGH)) demand = false;
      break;
      
    case MODE_TIMER:
      if (timerEndTime > 0 && now < timerEndTime) {
        demand = true;
      } else {
        demand = false;
        if (timerEndTime > 0 && timerEndTime < now) {
          timerEndTime = 0;
          sendNotification("Timer Complete", "Heating cycle finished");
        }
      }
      break;
      
    case MODE_CYCLE:
      if (cycleActive) {
        if (now < cycleOnEnd) {
          demand = true;
        } else {
          demand = false;
          if (cycleOffEnd == 0) {
            cycleOffEnd = now + (30 * 60 * 1000);
            cycleOnEnd = 0;
          } else if (now >= cycleOffEnd) {
            cycleOnEnd = now + (15 * 60 * 1000);
            cycleOffEnd = 0;
          }
        }
      } else {
        demand = false;
      }
      break;
  }
  
  setRelayState(demand, "AUTO");
}

// ==================== VISUALS & UI ENGINE ====================
void drawCenteredText(int xOffset, int y, const char* text, const uint8_t* font) {
  display.setFont(font);
  int w = display.getStrWidth(text);
  int x = (128 - w) / 2 + xOffset;
  display.setCursor(x, y);
  display.print(text);
}

void drawStatusDot(int x, int y, bool active, bool solid) {
  if (!active) display.drawCircle(x, y, 3);
  else if (solid || (now / 250) % 2 == 0) display.drawDisc(x, y, 3);
  else display.drawCircle(x, y, 3);
}

const char* getModeString() {
  switch (currentMode) {
    case MODE_TIMER: return "TIMER";
    case MODE_CYCLE: return "CYCLE";
    default: return "HEAT";
  }
}

void renderScreen(ScreenId id, int xOffset) {
  if (id == SCREEN_HOME) {
    display.drawHLine(xOffset, 14, 128);
    char statusText[32];
    snprintf(statusText, sizeof(statusText), "%s %s", getModeString(), systemEnabled ? "ON" : "OFF");
    drawCenteredText(xOffset, 11, statusText, u8g2_font_7x13B_mr);
    if (relayActive && (now / 250) % 2 == 0) display.drawDisc(xOffset + 120, 7, 3);
    
    char buf[10]; 
    dtostrf((now < targetDisplayTimeout) ? targetTemperature : temperature, 4, 1, buf);
    display.setFont(u8g2_font_fub30_tn);
    int w = display.getStrWidth(buf); 
    int x = (128 - (w + 14)) / 2 + xOffset;
    display.setCursor(x, 56); display.print(buf);
    display.setFont(u8g2_font_HelvetiPixel_tr); 
    display.setCursor(x+w+4, 38); display.print("o"); 
    display.setCursor(x+w+4, 46); display.print("C");
    
    if (currentError != ERR_NONE) drawCenteredText(xOffset, 63, "FAIL-SAFE ENGAGED", u8g2_font_HelvetiPixel_tr);
    else if (now < targetDisplayTimeout) drawCenteredText(xOffset, 63, "TARGET SETPOINT", u8g2_font_HelvetiPixel_tr);
    else drawCenteredText(xOffset, 63, "ROOM TEMP", u8g2_font_HelvetiPixel_tr);
  }
  else if (id == SCREEN_NET_LOCAL) {
    display.setDrawColor(1); display.drawBox(xOffset, 0, 128, 14); display.setDrawColor(0);
    drawCenteredText(xOffset, 10, "LOCAL NETWORK", u8g2_font_6x12_tr); display.setDrawColor(1);
    display.setFont(u8g2_font_HelvetiPixel_tr); int rowX = xOffset + 15;
    
    drawStatusDot(xOffset + 6, 26, apModeActive, true);
    display.setCursor(rowX, 29); display.print("AP: "); display.print(apSSID);
    
    bool slaveOk = slaveKnown && (now - lastSlavePacketTime < 2000);
    drawStatusDot(xOffset + 6, 38, true, slaveOk);
    display.setCursor(rowX, 41); display.print("Slave: "); display.print(slaveOk ? "Linked" : "Searching...");
    
    int clients = WiFi.softAPgetStationNum(); 
    drawStatusDot(xOffset + 6, 50, true, (clients > 0));
    display.setCursor(rowX, 53); display.print("Devices: "); display.print(clients);
    
    if (now - lastSlavePacketTime < 200) display.drawDisc(xOffset + 124, 38, 2);
  }
  else if (id == SCREEN_NET_CLOUD) {
    display.setDrawColor(1); display.drawBox(xOffset, 0, 128, 14); display.setDrawColor(0);
    drawCenteredText(xOffset, 10, "IOT CLOUD", u8g2_font_6x12_tr); display.setDrawColor(1);
    display.setFont(u8g2_font_HelvetiPixel_tr); int rowX = xOffset + 15;
    
    bool wifiOk = (WiFi.status() == WL_CONNECTED);
    drawStatusDot(xOffset + 6, 26, true, wifiOk);
    display.setCursor(rowX, 29); display.print("WiFi: "); 
    if(wifiOk) { String s = WiFi.SSID(); if(s.length() > 10) s = s.substring(0,10) + ".."; display.print(s); } else display.print("Disc.");
    
    drawStatusDot(xOffset + 6, 38, wifiOk, mqttClient.connected()); 
    display.setCursor(rowX, 41); display.print("Server: "); display.print(mqttClient.connected() ? "Online" : "Offline");
    
    drawStatusDot(xOffset + 6, 50, wifiOk, internetAvailable); 
    display.setCursor(rowX, 53); display.print("Internet: "); display.print(internetAvailable ? "OK" : "NO");

    display.setCursor(xOffset + 4, 60); display.print("IP: "); if(wifiOk) display.print(WiFi.localIP()); else display.print("---.---.---.---");
  }
  else if (id == SCREEN_IPS) {
    display.setDrawColor(1); display.drawBox(xOffset, 0, 128, 14); display.setDrawColor(0);
    drawCenteredText(xOffset, 10, "IP ADDRESSES", u8g2_font_6x12_tr); display.setDrawColor(1);
    display.setFont(u8g2_font_HelvetiPixel_tr); int rowX = xOffset + 5;
    
    display.setCursor(rowX, 28); display.print("AP IP:");
    display.setCursor(rowX + 55, 28); display.print(WiFi.softAPIP());
    
    bool wifiOk = (WiFi.status() == WL_CONNECTED);
    display.setCursor(rowX, 44); display.print("Router IP:");
    if(wifiOk) {
      display.setCursor(rowX + 55, 44); display.print(WiFi.localIP());
    } else {
      display.setCursor(rowX + 55, 44); display.print("Not Connected");
    }
  }
  else if (id == SCREEN_AP_CREDS) {
    display.setDrawColor(1); display.drawBox(xOffset, 0, 128, 14); display.setDrawColor(0);
    drawCenteredText(xOffset, 10, "AP CREDENTIALS", u8g2_font_6x12_tr); display.setDrawColor(1);
    display.setFont(u8g2_font_HelvetiPixel_tr); int rowX = xOffset + 5;
    
    display.setCursor(rowX, 28); display.print("SSID:");
    display.setCursor(rowX + 40, 28); display.print(apSSID);
    
    display.setCursor(rowX, 44); display.print("PASS:");
    display.setCursor(rowX + 40, 44); display.print(apPass);
    
    display.setFont(u8g2_font_5x7_tr);
    drawCenteredText(0, 60, "Connect to AP for setup", u8g2_font_5x7_tr);
  }
  else if (id == SCREEN_INFO) {
    drawCenteredText(xOffset, 18, "HELIOS SYSTEMS", u8g2_font_8x13B_mr);
    display.drawHLine(xOffset + 10, 24, 108);
    display.setFont(u8g2_font_HelvetiPixel_tr);
    drawCenteredText(xOffset, 38, "Firmware v19.0", u8g2_font_HelvetiPixel_tr);
    drawCenteredText(xOffset, 50, "Premium UI + IP Sync", u8g2_font_HelvetiPixel_tr);
    drawCenteredText(xOffset, 62, "(c) OrnithDynamics", u8g2_font_HelvetiPixel_tr);
  }
  else if (id == SCREEN_RESET) {
    drawCenteredText(xOffset, 12, "! DANGER ZONE !", u8g2_font_7x13B_mr);
    display.drawHLine(xOffset, 16, 128);
    if (resetHoldStart > 0) {
      long progress = now - resetHoldStart;
      int width = map(progress, 0, RESET_HOLD_MS, 0, 100); if (width > 100) width = 100;
      display.drawFrame(xOffset + 14, 30, 100, 10); display.drawBox(xOffset + 14, 30, width, 10);
      drawCenteredText(xOffset, 55, "HOLD TO WIPE", u8g2_font_HelvetiPixel_tr);
    } else {
      drawCenteredText(xOffset, 35, "Factory Reset?", u8g2_font_6x12_tr);
      drawCenteredText(xOffset, 55, "Hold SELECT 5s", u8g2_font_HelvetiPixel_tr);
    }
  }
}

// REDESIGNED: Now uses the Premium Popup Design (Rounded Box)
void drawAlertScreen() {
  // Semi-transparent background overlay
  display.setDrawColor(2);
  display.drawBox(0, 0, 128, 64);
  
  // Main popup container
  display.setDrawColor(1);
  display.drawRBox(10, 8, 108, 48, 6);
  
  // Inner container (for clean look)
  display.setDrawColor(0);
  display.drawRBox(11, 9, 106, 46, 5);
  display.setDrawColor(1);
  
  // Title
  display.setFont(u8g2_font_7x13B_mr);
  drawCenteredText(0, 20, "LINK LOST", u8g2_font_7x13B_mr);
  
  // Warning Icon
  display.setFont(u8g2_font_open_iconic_embedded_1x_t); 
  display.drawGlyph(32, 48, 0x45); // Warning icon

  // Single "Dismiss" button
  display.setFont(u8g2_font_7x13B_mr);
  if (selectedOption == OPTION_YES) { // Reusing YES as "Active/Highlight"
    display.setDrawColor(1);
    display.drawRBox(40, 30, 48, 16, 3);
    display.setDrawColor(0);
    drawCenteredText(0, 42, "OK", u8g2_font_7x13B_mr);
    display.setDrawColor(1);
  } else {
    // Should not happen for alert, but structure remains
    drawCenteredText(0, 42, "OK", u8g2_font_7x13B_mr);
  }
  
  // Instruction
  display.setFont(u8g2_font_5x7_tr);
  drawCenteredText(0, 60, "SELECT: DISMISS", u8g2_font_5x7_tr);
  
  display.sendBuffer();
}

void drawConfirmPopup() {
  display.setDrawColor(2); display.drawBox(0, 0, 128, 64);
  display.setDrawColor(1); display.drawRBox(10, 8, 108, 48, 6);
  display.setDrawColor(0); display.drawRBox(11, 9, 106, 46, 5); display.setDrawColor(1);
  drawCenteredText(0, 20, pendingRelayState ? "TURN ON?" : "TURN OFF?", u8g2_font_7x13B_mr);
  
  int arrowY = (selectedOption == OPTION_YES) ? 32 : 44;
  int arrowOffset = 0;
  if (now - lastScrollTime < SCROLL_ANIMATION_MS) {
    float progress = (float)(now - lastScrollTime) / SCROLL_ANIMATION_MS;
    arrowOffset = (int)((selectedOption == OPTION_YES ? progress : (1.0 - progress)) * 12);
  }
  arrowY += arrowOffset;
  if ((now / 250) % 2 == 0) display.drawTriangle(18, arrowY, 24, arrowY + 6, 18, arrowY + 12);
  
  display.setFont(u8g2_font_7x13B_mr);
  if (selectedOption == OPTION_YES) {
    display.setDrawColor(1); display.drawRBox(28, 28, 72, 16, 3); display.setDrawColor(0);
    display.setCursor(56, 40); display.print("YES"); display.setDrawColor(1);
    display.drawLine(40, 34, 42, 36); display.drawLine(42, 36, 46, 32);
  } else { display.setCursor(56, 40); display.print("YES"); }
  if (selectedOption == OPTION_NO) {
    display.setDrawColor(1); display.drawRBox(28, 40, 72, 16, 3); display.setDrawColor(0);
    display.setCursor(58, 52); display.print("NO"); display.setDrawColor(1);
    display.drawLine(40, 46, 46, 52); display.drawLine(46, 46, 40, 52);
  } else { display.setCursor(58, 52); display.print("NO"); }
  display.setFont(u8g2_font_5x7_tr);
  drawCenteredText(0, 60, "UP/DOWN: SELECT  |  SELECT: CONFIRM", u8g2_font_5x7_tr);
}

void updateDisplay() {
  if (currentError == ERR_SLAVE_LOST && !errorDismissed) {
    drawAlertScreen();
    return;
  }
  display.clearBuffer();
  if (isAnimating && currentScreen != targetScreen) {
    if (screenOffset > 0) {
      screenOffset -= 24; renderScreen(currentScreen, screenOffset - 128); renderScreen(targetScreen, screenOffset);
    } else {
      screenOffset += 24; renderScreen(currentScreen, screenOffset + 128); renderScreen(targetScreen, screenOffset);
    }
    if (abs(screenOffset) < 24) { screenOffset = 0; currentScreen = targetScreen; isAnimating = false; }
  } else {
    renderScreen(currentScreen, 0);
  }
  if (showConfirmPopup) drawConfirmPopup();
  display.sendBuffer();
}

// ENHANCED: Prevents state leakage to main handler
void handlePopupNavigation() {
  bool sel = digitalRead(BTN_SELECT) == LOW;
  bool up = digitalRead(BTN_UP) == LOW;
  bool down = digitalRead(BTN_DOWN) == LOW;
  
  if (sel && !buttonHandled) {
    buttonHandled = true; playTone(1500, 100);
    if (selectedOption == OPTION_YES) {
      targetTemperature = pendingTargetTemp; targetDisplayTimeout = now + 1500; showConfirmPopup = false; playTone(3000, 200);
    } else { showConfirmPopup = false; playTone(500, 200); } 
    // CRITICAL FIX: Reset main handler timers to prevent menu entry
    selectPressStart = 0; 
    longPressTriggered = false;
    return;
  }
  if (up && !buttonHandled) { buttonHandled = true; if (selectedOption != OPTION_YES) { selectedOption = OPTION_YES; lastScrollTime = now; playTone(800, 50); } return; }
  if (down && !buttonHandled) { buttonHandled = true; if (selectedOption != OPTION_NO) { selectedOption = OPTION_NO; lastScrollTime = now; playTone(600, 50); delay(250); } return; }
  if (!sel && !up && !down) buttonHandled = false;
}

// ENHANCED: Prevents state leakage to main handler
void handleAlertNavigation() {
  bool sel = digitalRead(BTN_SELECT) == LOW;
  bool up = digitalRead(BTN_UP) == LOW;
  bool down = digitalRead(BTN_DOWN) == LOW;
  
  if (sel && !buttonHandled) {
    buttonHandled = true; 
    if (selectedOption == OPTION_YES) { errorDismissed = true; playTone(1000, 100); } 
    // CRITICAL FIX: Reset main handler timers
    selectPressStart = 0;
    longPressTriggered = false;
    return;
  }
  if ((up || down) && !buttonHandled) {
    buttonHandled = true; selectedOption = (selectedOption == OPTION_YES) ? OPTION_NO : OPTION_YES; lastScrollTime = now; playTone(700, 50); return;
  }
  if (!sel && !up && !down) buttonHandled = false;
}

void handleInput() {
  if (now - t_input < 50) return; t_input = now;
  if (showConfirmPopup) { handlePopupNavigation(); return; }
  if (currentError == ERR_SLAVE_LOST && !errorDismissed) { handleAlertNavigation(); return; }
  
  bool sel = digitalRead(BTN_SELECT) == LOW;
  bool up = digitalRead(BTN_UP) == LOW;
  bool down = digitalRead(BTN_DOWN) == LOW;
  
  if (currentScreen != SCREEN_HOME) {
    if (sel && !longPressTriggered) {
      if(selectPressStart == 0) selectPressStart = now;
    } else if (!sel && selectPressStart > 0 && !longPressTriggered) {
      if (!isAnimating) {
        targetScreen = SCREEN_HOME;
        screenOffset = -128;
        isAnimating = true;
      }
      selectPressStart = 0;
    }
    if (now - lastTempAdjustTime > 200) {
      if (up && !isAnimating) {
        int prev = currentScreen - 1;
        if (prev < SCREEN_NET_LOCAL) prev = SCREEN_RESET;
        targetScreen = (ScreenId)prev;
        screenOffset = -128;
        isAnimating = true;
        lastTempAdjustTime = now;
        playTone(400, 30);
      } else if (down && !isAnimating) {
        int next = currentScreen + 1;
        if (next >= SCREEN_COUNT) next = SCREEN_NET_LOCAL;
        targetScreen = (ScreenId)next;
        screenOffset = 128;
        isAnimating = true;
        lastTempAdjustTime = now;
        playTone(400, 30);
      }
    }
  }
  if (currentScreen == SCREEN_HOME) {
    if (sel && !longPressTriggered) {
      if (selectPressStart == 0) selectPressStart = now;
    } else if (!sel && selectPressStart > 0 && !longPressTriggered) {
      if (!isAnimating) {
        targetScreen = SCREEN_NET_LOCAL;
        screenOffset = 128;
        isAnimating = true;
        playTone(500, 30);
      }
      selectPressStart = 0;
    }
    if (now - lastTempAdjustTime > 150) { 
      if (up || down) {
        if (systemEnabled) {
          float potentialTarget = targetTemperature + (up ? 0.5 : -0.5);
          bool nextRelayState = relayActive;
          if (temperature <= (potentialTarget - HYSTERESIS_LOW)) nextRelayState = true;
          else if (temperature >= (potentialTarget + HYSTERESIS_HIGH)) nextRelayState = false;
          if (nextRelayState != relayActive) {
            pendingTargetTemp = potentialTarget; pendingRelayState = nextRelayState; showConfirmPopup = true; selectedOption = OPTION_YES; playTone(1200, 100);
          } else { targetTemperature = potentialTarget; targetDisplayTimeout = now + 1500; playTone(600, 50); }
        } else {
          if(up) targetTemperature += 0.5; else targetTemperature -= 0.5;
          targetDisplayTimeout = now + 1500; playTone(600, 50);
        }
        lastTempAdjustTime = now;
      }
    }
  }
  if (sel) {
    if (selectPressStart == 0) selectPressStart = now;
    if (currentScreen == SCREEN_RESET) {
      if (now - selectPressStart > RESET_DEBOUNCE_MS) {
        if (resetHoldStart == 0) resetHoldStart = now;
        if (now - resetHoldStart > RESET_HOLD_MS) {
          playTone(3000, 1000); WifiSettings empty; empty.magic = 0; EEPROM.put(0, empty); EEPROM.commit(); ESP.restart();
        }
      }
    } else {
      if (!longPressTriggered && (now - selectPressStart > LONG_PRESS_MS)) {
        longPressTriggered = true; systemEnabled = !systemEnabled; playTone(2000, 100); delay(100); playTone(3000, 100);
        publishStatus("MANUAL_OVERRIDE"); sendNotification("Power", systemEnabled ? "Manual ON" : "Manual OFF");
      }
    }
  } else {
    if (selectPressStart > 0) selectPressStart = 0;
    longPressTriggered = false;
    resetHoldStart = 0; 
  }
}

void setup() {
  Serial.begin(115200); delay(100);
  pinMode(RELAY_PIN, OUTPUT); digitalWrite(RELAY_PIN, HIGH);
  pinMode(BUZZER_PIN, OUTPUT); digitalWrite(BUZZER_PIN, LOW);
  pinMode(BTN_UP, INPUT_PULLUP); pinMode(BTN_DOWN, INPUT_PULLUP); pinMode(BTN_SELECT, INPUT_PULLUP);

  EEPROM.begin(512); EEPROM.get(0, wifiCreds);
  display.begin(); display.clearBuffer(); drawCenteredText(0, 38, "HELIOS SYSTEMS", u8g2_font_bpixeldouble_tr); display.sendBuffer();
  playStartupSound();
  
  if (!aht.begin()) currentError = ERR_SENSOR_FAIL;

  WiFi.mode(WIFI_AP_STA);
  WiFi.softAP(apSSID, apPass);
  if (wifiCreds.magic == 0x55) WiFi.begin(wifiCreds.ssid, wifiCreds.pass);

  espClient.setInsecure();
  mqttClient.setServer(mqtt_server, mqtt_port);
  mqttClient.setCallback(mqttCallback);
  mqttClient.setKeepAlive(30);
  mqttClient.setSocketTimeout(10);

  udp.begin(udpPort);
  server.on("/", [](){ server.send_P(200, "text/html", INDEX_HTML); });
  server.on("/scan", handleScan);
  server.on("/save_wifi", HTTP_POST, handleSaveWifi);
  server.on("/api/command", HTTP_POST, handleApiCommand);
  server.on("/api/status", HTTP_GET, handleApiStatus);
  
  httpUpdater.setup(&server, "/update", "admin", "admin");
  ArduinoOTA.setHostname("Helios-Master");
  ArduinoOTA.setPassword("admin");
  
  ArduinoOTA.onStart([]() { Serial.println("OTA Start"); });
  ArduinoOTA.onEnd([]() { Serial.println("\nOTA End"); });
  ArduinoOTA.onProgress([](unsigned int progress, unsigned int total) { Serial.printf("Progress: %u%%\n", (progress / (total / 100))); });
  ArduinoOTA.onError([](ota_error_t error) { Serial.printf("Error[%u]: ", error); });
  ArduinoOTA.begin();
  
  MDNS.begin("helios");
  server.begin();
  
  watchdogTimer = millis();
}

void loop() {
  now = millis();
  ESP.wdtFeed();
  ArduinoOTA.handle();
  server.handleClient();

  if (!startupApLaunched && now > 3000) { 
    startupApLaunched = true; toggleAPMode(true); playTone(2000, 50); 
    sendNotification("System", "Helios Master v19.0 Online");
  }
  
  if (apModeActive) { 
    receivePacket(); 
    if (now - t_heartbeat > HEARTBEAT_MS) { t_heartbeat = now; sendUdpBroadcast(); }
  }
  
  if (now - t_internet > INTERNET_CHECK_MS) {
    t_internet = now;
    bool wifiOk = (WiFi.status() == WL_CONNECTED);
    internetAvailable = wifiOk ? probeInternet() : false;
    if (internetAvailable && !mqttClient.connected()) connectMqtt();
  }

  if (!mqttClient.connected()) connectMqtt();
  else mqttClient.loop();
  
  runThermostatLogic();

  if (now - t_sensor > SENSOR_READ_MS) {
    t_sensor = now;
    sensors_event_t h, t;
    if (aht.getEvent(&h, &t)) {
      temperature = t.temperature; humidity = h.relative_humidity;
      if (now - lastStatusPublish > 10000) { lastStatusPublish = now; publishStatus("PERIODIC"); }
    } else if (currentError == ERR_NONE) currentError = ERR_SENSOR_FAIL;
  }
  
  handleInput();
  if (now - t_display > DISPLAY_UPDATE_MS) { t_display = now; updateDisplay(); }
}
